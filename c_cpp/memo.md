类与类之间存在以下关系: 

(1)泛化(Generalization)

表示类与类之间的继承关系，接口与接口之间的继承关系，或类对接口的实现关系。一般化的关系是从子类指向父类的，与继承或实现的方法相反。    

(2)关联(Association)

对于两个相对独立的对象，当一个对象的实例与另一个对象的一些特定实例存在固定的对应关系时，这两个对象之间为关联关系。 

(3)依赖(Dependency)  

对于两个相对独立的对象，当一个对象负责构造另一个对象的实例，或者依赖另一个对象的服务时，这两个对象之间主要体现为依赖关系。      

(4)聚合(Aggregation) 

当对象A被加入到对象B中，成为对象B的组成部分时，对象B和对象A之间为聚集关系。聚合是关联关系的一种，是较强的关联关系，强调的是整体与部分之间的关系。 

abbr|description
---|---
API|Application Programming Interface //操作系统提供给应用程序编程的接口 
SDK|Software Develop Kit //软件开发工具 
MFC|Microsoft Foundation Classes//建立在Windows API之上的C++类库 
Application Framework|关联性更强的类库 
UML|一种可视化建模语言，主要用于面向对象分析和建模 

构造函数 

1. 构造函数最重要的作用是创建对象本身 。 

2. C++规定，每个类必须有一个构造函数，没有构造函数，就不能创建任何对象。  

3. C++又规定，如果一个类没有提供任何的构造函数，则C++提供一个默认的构造函数（由C++编译器提供），这个默认的构造函数是一个不带参数的构造函数，它只负责创建对象，而不做任何的初始化工作。 

4. 只要一个类定义了一个构造函数，不管这个构造函数是否是带参数的构造函数，C++就不再提供默认的构造函数。也就是说，如果为一个类定义了一个带参数的构造函数，还想要无参数的构造函数，则必须自己定义。 

析构函数 

1. 当一个对象生命周期结束时，其所占有的内存空间就要被回收，这个工作就由析构函数来完成。 

2. 析构函数是“反向”的构造函数，析构函数不允许有返回值，更重要的是析构函数不允许带参数，并且一个类中只能有一个析构函数。  

3. 析构函数的作用正好与构造函数相反，对象超出其作用范围，对应的内存空间被系统收回或被程序用delete删除时，析构函数被调用。 

4. 根据析构函数的这种特点，我们可以在构造函数中初始化对象的某些成员变量，给其分配内存空间（堆内存），在析构函数中释放对象运行期间所申请的资源。  

函数的重载 

重载构成的条件：函数的参数类型、参数个数不同，才能构成函数的重载。 

this指针 

1. this指针是一个隐含的指针，它是指向对象本身，代表了对象的地址 

2. 一个类所有的对象调用的成员函数都是同一代码段。那么成员函数又是怎么识别属于同一对象的数据成员呢？原来，在对象调用pt.output(10,10)时，成员函数除了接受2个实参外，还接受到了一个对象s的地址。这个地址被一个隐含的形参this指针所获取，它等同于执行this=&pt。所有对数据成员的访问都隐含地被加上前缀this->。例如：x=0; 等价于 this->x=0。     

Math

fun|description
---|---
pow(m,n)|m 的 n 次幂 
sqrt(x)|平方根，x>0 
fabs(x)|绝对值 
log(x)|计算lnx，x>0 
log10(x)|
exp(x)|e的x次幂 
sin(x)|
cos(x)|x为弧度值，而非角度值 
ch ＝ ch －32|化为大写 
 
cin 输入字符串遇到空格停止，若输入完整一句话：

    getline(cin,string_name); 

输出随机数，范围 n～n＋m－1

    //  输出随机数，范围 n～n＋m－1 
    // 
    //  Created by luanxxy on 8/31/16. 
    //  Copyright © 2016 luanxxy. All rights reserved. 
    // 
     
    #include <iostream> 
    #include <ctime> 
    const int m = 9; 
    const int n = 3; 
     
    int main() 
    { 
        double num; 
        srand(time(NULL)); 
        num = time(NULL)%m + n; 
        std::cout << num << std::endl; 
     
        return 0; 
    } 
