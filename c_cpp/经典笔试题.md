1. 什么是“引用”？申明和使用“引用”要注意哪些问题？ 

引用就是某个目标变量的“别名”(alias)，对引用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。引用声明完毕后，相当于目标变量有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量的别名。声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量的一个别名，它本身不是一种数据类型，此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。 

2. 将“引用”作为函数参数有哪些特点？ 

(1) 传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。 

(2) 使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。此外，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。 

(3) 使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 

3. 在什么时候需要使用“常引用”？ 

如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用“常引用”。“常引用”声明方式：const 类型标识符 &引用名 = 目标变量名。

例1

    int a; 
    const int &ra=a; 
    ra=1; //错误 
    a=1; //正确 
  
例2

    string foo( ); 
    void bar(string &s); 
那么下面的表达式将是非法的： 

    bar(foo( )); 
    bar("hello world"); 

原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。因此，上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。 
引用参数在能被定义为const的情况下，尽量定义为const。 

4. 将“引用”作为函数返回值类型的格式、好处和需要遵守的规则? 

格式：类型标识符 & 函数名（形参列表及类型说明）{ //函数体 } 

好处：在内存中不产生被返回值的副本。（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!） 

注意事项： 

(1) 不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了“无所指”的引用，程序会进入未知状态。 

(2) 不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成内存泄漏（memory leak）。 

(3) 可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。 

(4) 流操作符重载返回值申明为“引用”的作用。流操作符<<和>>，这两个操作符常常希望被连续使用，例如：cout << "hello" << endl;这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个<<操作符实际上是针对不同对象的，这无法让人接受。对于返回一个流指针则不能连续使用<<操作符。因此，返回一个流对象引用是唯一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。赋值操作符“=”，这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。引用成了这个操作符的唯一返回值选择。 

例3 

    #include <iostream.h> 
      
    int &put(int n); 
    int vals[10]; 
    int error = -1; 
      
    void main() 
    { 
    put(0) = 10; // 以put(0)函数值作为左值，等价于vals[0]=10; 
    put(9) = 20; // 以put(9)函数值作为左值，等价于vals[9]=20; 
    cout << put(0) << " " << put(9) << endl; 
    } 
      
    int &put(int n) 
    { 
    if (n >= 0 && n <= 9) 
    return vals[n]; 
    else 
    { 
    cout << "subscript error"; 
    return error; 
    } 
    }

(5) 在另外的一些操作符中，却千万不能返回引用：+-*/四则运算符。它们不能返回引用，Effective C++[1]的Item 23详细地讨论了这个问题。主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用、返回一个new分配的对象的引用、返回一个静态对象引用。根据前面提到的引用作为返回值的三个规则，第2、3两个方案都被否决。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误，所以可选的只剩下返回一个对象。 

5. “引用”与多态的关系？ 

引用是除指针外另一个可以产生多态效果的手段。这意味着，一个基类的引用可以指向它的派生类实例。 

例4 

    Class A; 
    Class B : Class A{...}; 
    B b; 
    A &ref = b; 

6. “引用”与指针有什么区别？ 

(1) 引用必须被初始化，但是不分配存储空间。指针可以在声明时不初始化，在初始化的时候需要分配存储空间； 

(2) 引用初始化以后不能被改变，指针可以改变所指的对象； 

(3) 不存在指向空值的引用，但是存在指向空值的指针。 

7. 什么时候需要“引用”？ 

流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。 

8. 关联、聚合(Aggregation)以及组合(Composition)的区别？ 

涉及到UML中的一些概念：关联是表示两个类的一般性联系，比如“学生”和“老师”就是一种关联关系；聚合表示has-a的关系，是一种相对松散的关系，聚合类不需要对被聚合类负责，用空的菱形表示聚合关系： 
从实现的角度讲，聚合可以表示为： 

    class A { ... } 
    class B { A *a; ... } 

而组合表示contains-a的关系，关联性强于聚合：组合类与被组合类有相同的生命周期，组合类要对被组合类负责，采用实心的菱形表示组合关系： 

实现的形式是： 

    class A{...} 
    class B{ A a; ... } 

9. 面向对象的三个基本特征，并简单叙述之？ 


(1) 封装：将客观事物抽象成类，每个类对自身的数据和方法实行protection(private, protected, public)。 

(2) 继承：广义的继承有三种实现形式：实现继承（使用基类的属性和方法而无需额外编码的能力）、可视继承（子窗体使用父窗体的外观和实现代码）、接口继承（仅使用属性和方法的名称、实现滞后到子类实现）。 

(3) 多态：是将父对象设置成为和一个或更多的它的子对象相等的技术，用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。 

10. 重载（overload）和重写（overwrite，有的书也叫做“覆盖”）的区别？（常考的题目） 

从定义上来说： 

    重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。 

    重写：是指子类重新定义父类虚函数。 

从实现原理上来说： 

    重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。如，有两个同名函数：spiff(int)和spiff(double,double)。那么编译器做过修饰后的函数名称可能是这样的：_spiff_i、_spiff_d_d。对于这两个函数的调用，在编译期间就已经确定了，是静态的。也就是说，它们的地址在编译期间就已绑定（早绑定），因此，重载和多态无关！ 

    重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。 

11. 如何判断一个单链表是有环的？（注意不能用标志位，最多只能用两个额外指针） 

    struct node {char val; node *next;} 
    bool check(const node *head) {}//return false :无环；true:  有环 

一种O(n)的办法就是（搞两个指针，一个每次递增一步，一个每次递增两步，如果有环的话两者必然重合，反之亦然）： 

    bool check(const node *head) 
    { 
    if (head == NULL) 
    return false; 
    node *low = head; 
    node *fast = head->next; 
    while (fast != NULL && fast->next != NULL) 
    { 
    low = low->next; 
    fast = fast->next->next; 
    if (low == fast) 
    return true; 
    } 
    return false; 
    } 

12. 多态的作用？ 

主要是两个： 

(1) 扩展代码模块，实现代码重用； 

(2) 接口重用：为了类在派生的时候，保证使用家族中任一类的实例的某一属性时的正确调用。 

13. ADO与ADO.NET的相同与不同？ 

除了能够让应用程序处理存储于DBMS中的数据这一基本相似点外，两者没有太多共同之处。但是ADO使用OLE DB接口并基于微软的COM技术，而ADO.NET拥有自己的ADO.NET接口并且基于微软的.NET体系架构。众所周知，.NET体系不同于COM体系，ADO.NET接口也就完全不同于ADO和OLE DB接口，这也就是说ADO.NET和ADO是两种数据访问方式。ADO.NET提供对XML的支持。 

14. C++是不是类型安全的？ 

不是。两个不同类型的指针之间可以强制转换（用reinterpret_cast）。C#是类型安全的。 

15. 描述内存分配方式以及它们的区别? 

(1) 从静态存储区域分配。内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。速度快、不容易出错，因为有系统会善后。例如全局变量，static变量等。 

(2) 在栈上分配。在执行函数时，函数内局部变量的存储单元都可在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 

(3) 从堆上分配，即动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。 

16. 当一个类A中没有声明任何成员变量与成员函数，这时sizeof(A)
的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk） 
肯定不是零。举个反例，如果是零的话，声明一个A a[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分a[0]，a[1]，…。 

17. 在8086汇编下，逻辑地址和物理地址是怎样转换的？（Intel） 

通用寄存器给出的地址是段内偏移地址，相应段寄存器地址*10H+通用寄存器内地址，就得到了真正要访问的地址。 

18. 分别写出BOOL,int,float,指针类型的变量a与零的比较语句。 

    BOOL : if (!a) or if(a) 
    int : if ( a == 0) 
    float : const EXPRESSION EXP = 0.000001 
    if (a < EXP && a >-EXP) 
    pointer : if (a != NULL) or if(a == NULL) 

19. 请说出const与#define相比，有何优点？ 

(1) const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。 

(2) 有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。 

20. 简述数组与指针的区别？ 

数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。 
(1) 修改内容上的差别 

    char a[] = "hello"; 
    a[0] = 'X'; 
    char *p = "world"; // 注意p指向常量字符串 
    p[0] = 'X';       // 编译器不能发现该错误，运行时错误 

(2) 用运算符sizeof可以计算出数组的容量（字节数）。sizeof(p)，p为指针得到的是一个指针变量的字节数，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。注意，当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。 

    char a[] = "hello world"; 
    char *p = a; 
    cout << sizeof(a) << endl; // 12字节 
    cout << sizeof(p) << endl; // 4字节 
    计算数组和指针的内存容量 
    void Func(char a[100]) 
    { 
    cout<< sizeof(a) << endl; // 4字节而不是100字节 
    } 

21. 类成员函数的重载. 覆盖和隐藏区别？ 

(1) 成员函数被重载的特征： 

    l相同的范围（在同一个类中）； 
    l函数名字相同； 
    l参数不同； 
    lvirtual关键字可有可无。 

(2) 覆盖是指派生类函数覆盖基类函数，特征是： 

    l不同的范围（分别位于派生类与基类）； 
    l函数名字相同； 
    l参数相同； 
    l基类函数必须有virtual关键字。 

(3) 隐藏是指派生类的函数屏蔽了与其同名的基类函数，规则如下： 

    l如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。 
    l如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）。 

22. There are two int variables: a and b,don't use "if","? :","switch" or other judgement statements, find out the biggest one of the two numbers. 

    ((a + b) + abs(a - b)) / 2 

23. 如何打印出当前源文件的文件名以及源文件的当前行号？ 

    cout << __FILE__; 
    cout << __LINE__; 

__FILE__和__LINE__是系统预定义宏，这种宏并不是在某个文件中定义的，而是由编译器定义的。 

24. main主函数执行完毕后，是否可能会再执行一段代码，给出说明？ 

可以，可以用_onexit注册一个函数，它会在main之后执行int fn1(void), int fn2(void), int fn3(void), int fn4(void)。 

    void main(void) 
    { 
    String str("zhanglin"); 
    _onexit(fn1); 
    _onexit(fn2); 
    _onexit(fn3); 
    _onexit(fn4); 
    printf("This is executed first.\n"); 
    } 
      
    int fn1() 
    { 
    printf("next.\n"); 
    return 0; 
    } 
      
    int fn2() 
    { 
    printf("executed "); 
    return 0; 
    } 
      
    int fn3() 
    { 
    printf("is "); 
    return 0; 
    } 
      
    int fn4() 
    { 
    printf("This "); 
    return 0; 
    } 

The _onexit function is passed the address of a function (func) to be called when the program terminates normally. Successive calls to _onexit create a register of functions that are executed in LIFO (last-in-first-out) order. The functions passed to _onexit cannot take parameters. 

25. 如何判断一段程序是由C编译程序还是由C++编译程序编译的？ 

    #ifdef __cplusplus 
    cout<<"c++"; 
    #else 
    cout<<"c"; 
    #endif 

26. 文件中有一组整数，要求排序后输出到另一个文件中。 

    #include <iostream> 
    #include <fstream> 
    #include <vector> 
    using namespace std; 
      
    void Order(vector<int> &data); 
      
    int main(void) 
    { 
    vector<int> data; 
    ifstream in("c:\\data.txt"); 
    if (in == NULL) 
    { 
    cout << "file error!"; 
    exit(1); 
    } 
    int temp; 
    while (!in.eof()) 
    { 
    in >> temp; 
    data.push_back(temp); 
    } 
    in.close();    // 关闭输入文件流 
    Order(data); 
    ofstream out("c:\\result.txt"); 
    if (!out) 
    { 
    cout << "file error!"; 
    exit(1); 
    } 
    for (i = 0; i < data.size(); i++) 
    { 
    out << data(i); 
    } 
    out.close();    // 关闭输出文件流 
    } 
      
    void Order(vector<int> &data) // bubble sort 
    { 
    int count = data.size() ; 
    int tag = false ; // 设置是否需要继续冒泡的标志位 
    for (int i = 1; i < count; i++) 
    { 
    for (int j = 0; j < count - i; j++) 
    { 
    if (data[j] > data[j+1]) 
    { 
    tag = true ; 
    int temp = data[j]; 
    data[j] = data[j+1]; 
    data[j+1] = temp; 
    } 
    } 
    if (!tag) 
    break; 
    } 
    } 

27. 链表题：一个链表的结点结构 

    struct Node 
    { 
    int data; 
    Node *next; 
    }; 
    typedef struct Node Node; 

(1) 已知链表的头指针head，写一个函数把这个链表逆序(Intel) 

    Node* ReverseList(Node *head)  // 链表逆序 
    { 
    Node *p = NULL; 
    Node *q = NULL; 
    if (head == NULL ) 
    return head; 
    p = head; 
    head = NULL; 
      
    while (p != NULL) 
    { 
    q = p; 
    p = p->next; 
    q->next = head; 
    head = q; 
    } 
    return head; 
    } 

(2) 已知两个链表head1和head2各自有序，请把它们合并成一个链表依然有序。(保留所有结点，即便大小相同） 

    Node* Merge(Node *head1, Node *head2) 
    { 
    if (head1 == NULL) 
    return head2; 
    if (head2 == NULL) 
    return head1; 
      
    Node *head = NULL; 
    Node *p1 = NULL; 
    Node *p2 = NULL; 
      
    if (head1->data < head2->data) 
    { 
    head = head1; 
    p1 = head1->next; 
    p2 = head2; 
    } 
    else 
    { 
    head = head2; 
    p2 = head2->next; 
    p1 = head1; 
    } 
      
    Node *pCur = head; 
    while (p1 != NULL && p2 != NULL) 
    { 
    if (p1->data <= p2->data) 
    { 
    pCur->next = p1; 
    pCur = p1; 
    p1 = p1->next; 
    } 
    else 
    { 
    pCur->next = p2; 
    pCur = p2; 
    p2 = p2->next; 
    } 
    } 
    if (p1 != NULL) 
    pCur->next = p1; 
    if (p2 != NULL) 
    pCur->next = p2; 
    return head; 
    } 

(3) 已知两个链表head1和head2各自有序，请把它们合并成一个链表依然有序，这次要求用递归方法进行。(Autodesk) 

    Node* MergeRecursive(Node *head1, Node *head2) 
    { 
    if (head1 == NULL) 
    return head2; 
    if (head2 == NULL) 
    return head1; 
    Node *head = NULL; 
    if (head1->data < head2->data) 
    { 
    head = head1; 
    head->next = MergeRecursive(head1->next,head2); 
    } 
    else 
    { 
    head = head2; 
    head->next = MergeRecursive(head1,head2->next); 
    } 
    return head ; 
    } 

28. 分析以下这段程序的输出(Autodesk) 

    class B 
    { 
    public: 
    B(){ cout<<"default constructor"<<endl; } 
    ~B(){ cout<<"destructed"<<endl; } 
    B(int i):data(i) // B(int) works as a converter (int -> instance of B) 
    { 
    cout<<"constructed by parameter " << data << endl; 
    } 
    private: 
    int data; 
    }; 
      
    B Play(B b) 
    { 
    return b; 
    } 
      
(1) results: 

    int main(int argc, char* argv[]) 
    { 
    B t1 = Play(5); // constructed by parameter 5,destructed B(5)形参析构 
    B t2 = Play(t1); // destructed t1形参析构 
      
    return 0; // destructed t2,destructed t1（注意顺序！） 
    } 
  
(2) results: 

    int main(int argc, char* argv[]) 
    { 
    B t1 = Play(5); // constructed by parameter 5,destructed B(5)形参析构 
    B t2 = Play(10); // constructed by parameter 10,destructed B(10)形参析构 
      
    return 0; // destructed t2,destructed t1（注意顺序！） 
    } 

29. 写一个函数找出一个整数数组中，第二大的数（Microsoft） 

    const int MINNUMBER = -32767; 
    int find_sec_max(int data[], int count) 
    { 
    int maxnumber = data[0]; 
    int sec_max = MINNUMBER; 
    for (int i = 1; i < count; i++) 
    { 
    if (data[i] > maxnumber) 
    { 
    sec_max = maxnumber; 
    maxnumber = data[i]; 
    } 
    else 
    { 
    if (data[i] > sec_max) 
    sec_max = data[i]; 
    } 
    } 
    return sec_max; 
    } 

30. 写一个在一个字符串(n)中寻找一个子串(m)第一个位置的函数 

KMP算法效率最好，时间复杂度是O(n+m)。 

31. 多重继承的内存分配问题：比如有class A : public class B, public class C 
{}那么A的内存结构大致是怎么样的？ 

这个是compiler-dependent的，不同的实现其细节可能不同。如果不考虑有虚函数、虚继承的话就相当简单；否则的话，相当复杂。 

可以参考《深入探索C++对象模型》，或者：http://blog.csdn.net/wfwd/archive/2006/05/30/763797.aspx 
